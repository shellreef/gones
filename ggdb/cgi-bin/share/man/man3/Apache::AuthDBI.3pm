.\" Automatically generated by Pod::Man version 1.15
.\" Tue Apr  1 15:23:59 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "AuthDBI 3"
.TH AuthDBI 3 "perl v5.6.1" "2003-02-17" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Apache::AuthDBI \- Authentication and Authorization via Perl's \s-1DBI\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Configuration in httpd.conf or startup.pl:
.Ve
.Vb 1
\& PerlModule Apache::AuthDBI
.Ve
.Vb 1
\& # Authentication and Authorization in .htaccess:
.Ve
.Vb 2
\& AuthName DBI
\& AuthType Basic
.Ve
.Vb 2
\& PerlAuthenHandler Apache::AuthDBI::authen
\& PerlAuthzHandler  Apache::AuthDBI::authz
.Ve
.Vb 4
\& PerlSetVar Auth_DBI_data_source   dbi:driver:dsn
\& PerlSetVar Auth_DBI_username      db_username
\& PerlSetVar Auth_DBI_password      db_password
\& #DBI->connect($data_source, $username, $password)
.Ve
.Vb 6
\& PerlSetVar Auth_DBI_pwd_table     users
\& PerlSetVar Auth_DBI_uid_field     username
\& PerlSetVar Auth_DBI_pwd_field     password
\& # authentication: SELECT pwd_field FROM pwd_table WHERE uid_field=$user
\& PerlSetVar Auth_DBI_grp_field     groupname
\& # authorization: SELECT grp_field FROM pwd_table WHERE uid_field=$user
.Ve
.Vb 3
\& require valid-user
\& require user   user_1  user_2 ...
\& require group group_1 group_2 ...
.Ve
The AuthType is limited to Basic. You may use one or more valid require lines. 
For a single require line with the requirement 'valid-user' or with the requirements 
\&'user user_1 user_2 ...' it is sufficient to use only the authentication handler.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows authentication and authorization against a database 
using Perl's \s-1DBI\s0. For supported \s-1DBI\s0 drivers see: 
.PP
.Vb 1
\& http://dbi.perl.org/
.Ve
Authentication:
.PP
For the given username the password is looked up in the cache. If the cache 
is not configured or if the user is not found in the cache, or if the given 
password does not match the cached password, it is requested from the database. 
.PP
If the username does not exist and the authoritative directive is set to 'on', 
the request is rejected. If the authoritative directive is set to 'off', the 
control is passed on to next module in line. 
.PP
If the password from the database for the given username is empty and the nopasswd 
directive is set to 'off', the request is rejected. If the nopasswd directive is set 
to 'on', any password is accepted. 
.PP
Finally the passwords (multiple passwords per userid are allowed) are 
retrieved from the database. The result is put into the environment variable 
\&\s-1REMOTE_PASSWORDS\s0. Then it is compared to the password given. If the encrypted 
directive is set to 'on', the given password is encrypted using perl's \fIcrypt()\fR 
function before comparison. If the encrypted directive is set to 'off' the 
plain-text passwords are compared. 
.PP
If this comparison fails the request is rejected, otherwise the request is 
accepted and the password is put into the environment variable \s-1REMOTE_PASSWORD\s0.
.PP
The SQL-select used for retrieving the passwords is as follows: 
.PP
.Vb 1
\& SELECT pwd_field FROM pwd_table WHERE uid_field = user
.Ve
If a pwd_whereclause exists, it is appended to the SQL-select.
.PP
This module supports in addition a simple kind of logging mechanism. Whenever 
the handler is called and a log_string is configured, the log_field will be 
updated with the log_string. As log_string \- depending upon the database \- 
macros like \s-1TODAY\s0 can be used. 
.PP
The SQL-select used for the logging mechanism is as follows: 
.PP
.Vb 1
\& UPDATE pwd_table SET log_field = log_string WHERE uid_field = user
.Ve
Authorization:
.PP
When the authorization handler is called, the authentication has already been 
done. This means, that the given username/password has been validated. 
.PP
The handler analyzes and processes the requirements line by line. The request 
is accepted if the first requirement is fulfilled. 
.PP
In case of 'valid-user' the request is accepted. 
.PP
In case of one or more user-names, they are compared with the given user-name 
until the first match. 
.PP
In case of one or more group-names, all groups of the given username are 
looked up in the cache. If the cache is not configured or if the user is not 
found in the cache, or if the requested group does not match the cached group, 
the groups are requested from the database. A comma separated list of all 
these groups is put into the environment variable \s-1REMOTE_GROUPS\s0. Then these 
groups are compared with the required groups until the first match. 
.PP
If there is no match and the authoritative directive is set to 'on' the 
request is rejected. 
.PP
In case the authorization succeeds, the environment variable \s-1REMOTE_GROUP\s0 is 
set to the group name, which can be used by user scripts without accessing
the database again.
.PP
The SQL-select used for retrieving the groups is as follows (depending upon 
the existence of a grp_table): 
.PP
.Vb 2
\& SELECT grp_field FROM pwd_table WHERE uid_field = user
\& SELECT grp_field FROM grp_table WHERE uid_field = user
.Ve
This way the group-information can either be held in the main users table, or 
in an extra table, if there is an m:n relationship between users and groups. 
From all selected groups a comma-separated list is build, which is compared 
with the required groups. If you don't like normalized group records you can 
put such a comma-separated list of groups (no spaces) into the grp_field 
instead of single groups. 
.PP
If a grp_whereclause exists, it is appended to the SQL-select.
.PP
Cache:
.PP
The module maintains an optional cash for all passwords/groups. See the
method \fIsetCacheTime\fR\|(n) on how to enable the cache. Every server has it's 
own cache. Optionally the cache can be put into a shared memory segment, 
so that it can be shared among all servers. See the \s-1CONFIGURATION\s0 section 
on how to enable the usage of shared memory. 
.PP
In order to prevent the cache from growing indefinitely a CleanupHandler can 
be initialized, which skips through the cache and deletes all outdated entries.
This can be done once per request after sending the response, hence without 
slowing down response time to the client. The minimum time between two successive 
runs of the CleanupHandler is configurable (see the \s-1CONFIGURATION\s0 section). The 
default is 0, which runs the CleanupHandler after every request. 
.SH "LIST OF TOKENS"
.IX Header "LIST OF TOKENS"
.Ip "\(bu Auth_DBI_data_source (Authentication and Authorization)"
.IX Item "Auth_DBI_data_source (Authentication and Authorization)"
The data_source value has the syntax 'dbi:driver:dsn'. This parameter is 
passed to the database driver for processing during connect. The data_source 
parameter (as well as the username and the password parameters) may be a 
tilde ('~') separated list of several data_sources. All of these triples will 
be used until a successful connect is made. This way several backup-servers can 
be configured. if you want to use the environment variable \s-1DBI_DSN\s0 instead of 
a data_source, do not specify this parameter at all. 
.Ip "\(bu Auth_DBI_username (Authentication and Authorization)"
.IX Item "Auth_DBI_username (Authentication and Authorization)"
The username argument is passed to the database driver for processing during 
connect. This parameter may be a tilde ('~') separated list. See the data_source 
parameter above for the usage of a list. 
.Ip "\(bu Auth_DBI_password (Authentication and Authorization)"
.IX Item "Auth_DBI_password (Authentication and Authorization)"
The password argument is passed to the database driver for processing during 
connect. This parameter may be a tilde ('~')  separated list. See the data_source 
parameter above for the usage of a list. 
.Ip "\(bu Auth_DBI_pwd_table (Authentication and Authorization)"
.IX Item "Auth_DBI_pwd_table (Authentication and Authorization)"
Contains at least the fields with the username and the (possibly encrypted) 
password. The username should be unique. 
.Ip "\(bu Auth_DBI_uid_field (Authentication and Authorization)"
.IX Item "Auth_DBI_uid_field (Authentication and Authorization)"
Field name containing the username in the Auth_DBI_pwd_table. 
.Ip "\(bu Auth_DBI_pwd_field (Authentication only)"
.IX Item "Auth_DBI_pwd_field (Authentication only)"
Field name containing the password in the Auth_DBI_pwd_table. 
.Ip "\(bu Auth_DBI_pwd_whereclause (Authentication only)"
.IX Item "Auth_DBI_pwd_whereclause (Authentication only)"
Use this option for specifying more constraints to the SQL-select.
.Ip "\(bu Auth_DBI_grp_table (Authorization only)"
.IX Item "Auth_DBI_grp_table (Authorization only)"
Contains at least the fields with the username and the groupname. 
.Ip "\(bu Auth_DBI_grp_field (Authorization only)"
.IX Item "Auth_DBI_grp_field (Authorization only)"
Field-name containing the groupname in the Auth_DBI_grp_table. 
.Ip "\(bu Auth_DBI_grp_whereclause (Authorization only)"
.IX Item "Auth_DBI_grp_whereclause (Authorization only)"
Use this option for specifying more constraints to the SQL-select.
.Ip "\(bu Auth_DBI_log_field (Authentication only)"
.IX Item "Auth_DBI_log_field (Authentication only)"
Field name containing the log string in the Auth_DBI_pwd_table. 
.Ip "\(bu Auth_DBI_log_string (Authentication only)"
.IX Item "Auth_DBI_log_string (Authentication only)"
String to update the Auth_DBI_log_field in the Auth_DBI_pwd_table. Depending 
upon the database this can be a macro like '\s-1TODAY\s0'. 
.Ip "\(bu Auth_DBI_authoritative  < on / off> (Authentication and Authorization)"
.IX Item "Auth_DBI_authoritative  < on / off> (Authentication and Authorization)"
Default is 'on'. When set 'on', there is no fall-through to other 
authentication methods if the authentication check fails. When this directive 
is set to 'off', control is passed on to any other authentication modules. Be 
sure you know what you are doing when you decide to switch it off. 
.Ip "\(bu Auth_DBI_nopasswd  < on / off > (Authentication only)"
.IX Item "Auth_DBI_nopasswd  < on / off > (Authentication only)"
Default is 'off'. When set 'on' the password comparison is skipped if the 
password retrieved from the database is empty, i.e. allow any password. This is 
\&'off' by default to ensure that an empty Auth_DBI_pwd_field does not allow people 
to log in with a random password. Be sure you know what you are doing when you 
decide to switch it on. 
.Ip "\(bu Auth_DBI_encrypted  < on / off > (Authentication only)"
.IX Item "Auth_DBI_encrypted  < on / off > (Authentication only)"
Default is 'on'. When set to 'on', the password retrieved from the database 
is assumed to be crypted. Hence the incoming password will be crypted before 
comparison. When this directive is set to 'off', the comparison is done directly 
with the plain-text entered password. 
.Ip "\(bu Auth_DBI_encryption_salt < password / userid > (Authentication only)"
.IX Item "Auth_DBI_encryption_salt < password / userid > (Authentication only)"
When crypting the given password AuthDBI uses per default the password selected 
from the database as salt. Setting this parameter to 'userid', the module uses 
the userid as salt. 
.Ip "\(bu Auth_DBI_uidcasesensitive  < on / off > (Authentication and Authorization)"
.IX Item "Auth_DBI_uidcasesensitive  < on / off > (Authentication and Authorization)"
Default is 'on'. When set 'off', the entered userid is converted to lower case.
Also the userid in the password select-statement is converted to lower case. 
.Ip "\(bu Auth_DBI_pwdcasesensitive  < on / off > (Authentication only)"
.IX Item "Auth_DBI_pwdcasesensitive  < on / off > (Authentication only)"
Default is 'on'. When set 'off', the entered password is converted to lower 
case. 
.Ip "\(bu Auth_DBI_placeholder < on / off > (Authentication and Authorization)"
.IX Item "Auth_DBI_placeholder < on / off > (Authentication and Authorization)"
Default is 'off'.  When set 'on', the select statement is prepared using a 
placeholder for the username.  This may result in improved performance for 
databases supporting this method.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
The module should be loaded upon startup of the Apache daemon.
Add the following line to your httpd.conf:
.PP
.Vb 1
\& PerlModule Apache::AuthDBI
.Ve
A common usage is to load the module in a startup file via the PerlRequire 
directive. See eg/startup.pl for an example. 
.PP
There are three configurations which are server-specific and which can be done 
in a startup file: 
.PP
.Vb 1
\& Apache::AuthDBI->setCacheTime(0);
.Ve
This configures the lifetime in seconds for the entries in the cache. 
Default is 0, which turns off the cache. When set to any value n > 0, the 
passwords/groups of all users will be cached for at least n seconds. After 
finishing the request, a special handler skips through the cache and deletes 
all outdated entries (entries, which are older than the CacheTime). 
.PP
.Vb 1
\& Apache::AuthDBI->setCleanupTime(-1);
.Ve
This configures the minimum time in seconds between two successive runs of the 
CleanupHandler, which deletes all outdated entries from the cache. The default 
is \-1, which disables the CleanupHandler. Setting the interval to 0 runs the
CleanupHandler after every request. For a heavily loaded server this should be 
set to a value, which reflects a compromise between scanning a large cache 
possibly containing many outdated entries and between running many times the 
CleanupHandler on a cache containing only few entries. 
.PP
.Vb 1
\& Apache::AuthDBI->initIPC(50000);
.Ve
This enables the usage of shared memory for the cache. Instead of every server 
maintaining it's own cache, all servers have access to a common cache. This 
should minimize the database load considerably for sites running many servers. 
The number indicates the size of the shared memory segment in bytes. This size 
is fixed, there is no dynamic allocation of more segments. As a rule of thumb 
multiply the estimated maximum number of simultaneously cached users by 100 to 
get a rough estimate of the needed size. Values below 500 will be overwritten 
with the default 50000. 
.PP
To enable debugging the variable \f(CW$Apache::AuthDBI::DEBUG\fR must be set. This 
can either be done in startup.pl or in the user script. Setting the variable 
to 1, just reports about a cache miss. Setting the variable to 2 enables full 
debug output. 
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
Note that this module needs mod_perl-1.08 or higher, apache_1.3.0 or higher 
and that mod_perl needs to be configured with the appropriate call-back hooks: 
.PP
.Vb 1
\&  PERL_AUTHEN=1 PERL_AUTHZ=1 PERL_CLEANUP=1 PERL_STACKED_HANDLERS=1
.Ve
.SH "SECURITY"
.IX Header "SECURITY"
In some cases it is more secure not to put the username and the password in 
the .htaccess file. The following example shows a solution to this problem:
.PP
httpd.conf:
.PP
.Vb 7
\& <Perl>
\& my($uid,$pwd) = My::dbi_pwd_fetch();
\& $Location{'/foo/bar'}->{PerlSetVar} = [
\&     [ Auth_DBI_username  => $uid ],
\&     [ Auth_DBI_password  => $pwd ],
\& ];
\& </Perl>
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the Apache manpage, the mod_perl manpage, the DBI manpage
.SH "AUTHORS"
.IX Header "AUTHORS"
.Ip "\(bu Apache::AuthDBI by Edmund Mergl; now maintained and supported by the modperl mailinglist, subscribe by sending mail to modperl-subscribe@perl.apache.org."
.IX Item "Apache::AuthDBI by Edmund Mergl; now maintained and supported by the modperl mailinglist, subscribe by sending mail to modperl-subscribe@perl.apache.org."
.PD 0
.Ip "\(bu mod_perl by Doug MacEachern."
.IX Item "mod_perl by Doug MacEachern."
.Ip "\(bu \s-1DBI\s0 by Tim Bunce <dbi-users-subscribe@perl.org>"
.IX Item "DBI by Tim Bunce <dbi-users-subscribe@perl.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The Apache::AuthDBI module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
