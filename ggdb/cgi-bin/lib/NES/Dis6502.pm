#!/usr/bin/perl
# Created:04-05-01
# By Jeff Connelly

# NES 6502 disassembler

=head1 NAME

NES::Dis6502 - Disassemble 6502 binary files

=head1 SYNOPSIS

    use NES::Dis6502;

    $cpu = new NES::Dis6502;

    print $cpu->op2asm(0x20, 0x22, 0x44);         # prints JSR #$4422

=head1 DESCRIPTION

=cut

package NES::Dis6502;

# Autogenerated by opcodes.pl
=head2 @opcodes

The package global @opcodes array is indexed by an opcode, 0 to 255.
It's contents are an array ref containing the mneumonic and the addressing
mode code.

Example:

    ($mneumonic, $addrmode) = @NES::Dis6502::opcodes[0x00];
    print "$mneumonic\n";   # BRK

=cut
@opcodes = (
# ==0==     ==1==     ==2==    ==3==     ==4==     ==5==     ==6==     ==7==
[BRK=> 9],[ORA=> 7],[___=> 0],[___=> 0],[___=> 0],[ORA=> 1],[ASL=> 1],[___=> 0],
[PHP=> 9],[ORA=> 0],[ASL=>10],[___=> 0],[___=> 0],[ORA=> 4],[ASL=> 4],[___=> 0],
[ORA=> 5],[ORA=> 8],[___=> 0],[___=> 0],[___=> 0],[ORA=> 2],[ASL=> 2],[___=> 0],
[CLC=> 9],[ORA=> 6],[___=> 0],[___=> 0],[___=> 0],[___=> 0],[ASL=> 5],[___=> 0],
[JSR=> 4],[AND=> 7],[___=> 0],[___=> 0],[BIT=> 1],[AND=> 1],[ROL=> 1],[___=> 0],
[PLP=> 9],[AND=> 0],[ROL=>10],[___=> 0],[BIT=> 4],[AND=> 4],[ROL=> 4],[___=> 0],
[BMI=>12],[AND=> 8],[___=> 0],[___=> 0],[___=> 0],[AND=> 2],[ROL=> 2],[___=> 0],
[SEC=> 9],[AND=> 6],[___=> 0],[___=> 0],[___=> 0],[AND=> 5],[ROL=> 5],[___=> 0],
[EOR=> 4],[EOR=> 7],[___=> 0],[___=> 0],[___=> 0],[EOR=> 1],[LSR=> 1],[___=> 0],
[PHA=> 9],[EOR=> 0],[LSR=>10],[___=> 0],[JMP=> 4],[RTI=> 9],[LSR=> 4],[___=> 0],
[EOR=> 5],[EOR=> 8],[___=> 0],[___=> 0],[___=> 0],[EOR=> 2],[LSR=> 2],[___=> 0],
[CLI=> 9],[EOR=> 6],[___=> 0],[___=> 0],[___=> 0],[___=> 0],[LSR=> 5],[___=> 0],
[RTS=> 9],[ADC=> 7],[___=> 0],[___=> 0],[___=> 0],[ADC=> 1],[ROR=> 1],[___=> 0],
[PLA=> 9],[ADC=> 0],[ROR=>10],[___=> 0],[JMP=>12],[___=> 0],[ROR=> 4],[___=> 0],
[BVS=>12],[ADC=> 8],[___=> 0],[___=> 0],[___=> 0],[ADC=> 2],[ROR=> 2],[___=> 0],
[SEI=> 9],[ADC=> 6],[___=> 0],[___=> 0],[___=> 0],[___=> 0],[ROR=> 5],[___=> 0],
[STA=> 4],[STA=> 7],[___=> 0],[___=> 0],[STY=> 1],[STA=> 1],[STX=> 1],[___=> 0],
[DEY=> 9],[___=> 0],[TXA=> 9],[___=> 0],[STY=> 4],[___=> 0],[STX=> 4],[___=> 0],
[STA=> 5],[STA=> 8],[___=> 0],[___=> 0],[STY=> 2],[STA=> 2],[STX=> 2],[___=> 0],
[TYA=> 9],[STA=> 6],[TXS=> 9],[___=> 0],[___=> 0],[___=> 0],[___=> 0],[___=> 0],
[LDY=> 0],[LDA=> 7],[LDX=> 0],[___=> 0],[LDY=> 1],[LDA=> 1],[LDX=> 1],[___=> 0],
[TAY=> 9],[LDA=> 0],[TAX=> 9],[___=> 0],[LDY=> 4],[LDA=> 4],[LDX=> 4],[___=> 0],
[BCS=>12],[LDA=> 8],[___=> 0],[___=> 0],[LDY=> 2],[LDA=> 2],[LDX=> 3],[___=> 0],
[CLV=> 9],[LDA=> 6],[TSX=> 9],[___=> 0],[LDY=> 5],[LDA=> 5],[LDX=> 6],[___=> 0],
[CPY=> 0],[CMP=> 7],[___=> 0],[___=> 0],[CPY=> 1],[CMP=> 1],[DEC=> 1],[___=> 0],
[INY=> 9],[CMP=> 0],[DEX=> 9],[___=> 0],[CPY=> 2],[CMP=> 4],[DEC=> 4],[___=> 0],
[BNE=>12],[CMP=> 8],[___=> 0],[___=> 0],[___=> 0],[CMP=> 2],[DEC=> 2],[___=> 0],
[CLD=> 9],[CMP=> 6],[___=> 0],[___=> 0],[___=> 0],[CMP=> 5],[DEC=> 5],[___=> 0],
[CPX=> 0],[SBC=> 7],[___=> 0],[___=> 0],[CPX=> 1],[SBC=> 1],[INC=> 1],[___=> 0],
[INX=> 9],[SBC=> 0],[NOP=> 9],[___=> 0],[CPX=> 2],[SBC=> 4],[INC=> 4],[___=> 0],
[BEQ=>12],[SBC=> 8],[___=> 0],[___=> 0],[___=> 0],[SBC=> 2],[INC=> 2],[___=> 0],
[SED=> 9],[SBC=> 6],[___=> 0],[___=> 0],[___=> 0],[SBC=> 5],[INC=> 5],[___=> 0],
);

=head2 @addrmodes

The package global @addrmode, indexed by an addrmode code (see @opcodes),
contains an array ref of the operand length, and the operand decoder.

=cut

# Addressing modes. These determine how the operand is interpreted, as well
# as the size of the operand.
@addrmodes = (
# Code Bytes    Format function
# TODO: instead of using $%.2X, use a general number representation function
[ 1, sub { sprintf '#$%.2X',$_[0]} ],     # Immediate
[ 1, sub { sprintf '$%.2X',$_[0]} ],      # Zero page
[ 1, sub { sprintf '$%.2X,X',$_[0]} ],    # Indexed X Zero Page 
[ 1, sub { sprintf '$%.2X,Y',$_[0]} ],    # Indexed Y Zero Page
[ 2, sub { sprintf '#$%.4X',($_[0])+(($_[1])*0x100)} ],     # Absolute
[ 2, sub { sprintf '$%.4X,X',($_[0])+(($_[1])*0x100)} ],    # Indexed X
[ 2, sub { sprintf '$%.4X,Y',($_[0])+(($_[1])*0x100)} ],    # Indexed Y
[ 1, sub { sprintf '($%.2X,X)', $_[0] } ],  # Pre-indexed indirect
[ 1, sub { sprintf '($%.2X),Y', $_[0] } ],  # Post-indexed indirect
[ 0, sub { '' } ],                        # Implied
[ 0, sub { 'A' } ],                       # Accumulator
[ 2, sub { sprintf '($%.4X)', ($_[0])+(($_[1])*0x100)} ],    # Indirect (used w/ jump)
[ 1, sub { sprintf '$%.4X', sign_num($_[0])+$_[1] } ], # Relative
);

sub new
{
    my ($self) = @_;

    $self = {};
    bless $self;
    return $self;
}

# Decode two bytes into a 4-hex-digit number, 6502 (little endian) format
sub dec4
{
    my ($a, $b);
    print "dec4 $a, $b\n";
    return $a + ($b * 0x0100);
}

=head2 ($asm, $offset) = $cpu->op2asm($bytes_arrayref, $offset)
=head2 $asm = $cpu->op2asm($bytes_arrayref, $offset)

Disassembles the first instruction in $bytes_arrayref into a 6502 assembly language
instruction. The array is modified to contain only bytes which were not disassembled.
$offset specifies where to start disassembling in the array, and defaults to 0 if not
specified. In array context, the $offset returned is where the instruction ends.

=cut

sub op2asm
{
    my ($self, $bytes, $offset) = @_;
    my ($mneumonic, $addrmode, $length, $decoder, $operand);

    $offset = 0 if !defined($offset);

    ($mneumonic, $addrmode) = @{$opcodes[$bytes->[$offset]]};
    $offset++;                     # skip opcode

    return ("???", $offset) if $mneumonic eq '___';
    return ($mneumonic, $offset) if $offset >= @$bytes;

    ($length, $decoder) = @{$addrmodes[$addrmode]};
   
    $operand = $decoder->(@$bytes[$offset..($length + $offset)], $offset);

    $offset += $length;            # skip operand

    return wantarray ? ("$mneumonic $operand", $offset)
                     :  "$mneumonic $operand";
}

# Treat an unsigned one-byte number as signed
sub sign_num
{
    my ($num) = @_;
    return $num if ! ($num & 0x80);  # Positive, bit 128 is clear
    $num |= 0x7f;                    # Mask out bit 128
    return -$num - 1;                       # Negative, two's complement

    #return 0x80 - $num - 1;  # Negative, 0x80=-1, 0x81=-2, etc.
}    

